import lexical_Analyzer

tokens = lexical_Analyzer.lexical_analyzer('program.c')

from parsimonious.grammar import Grammar
from parsimonious.exceptions import ParseError

# Define the CFG for C programming language using BNF notation
grammar = Grammar(
    r"""
    program = declaration*

    declaration = include_directive / function_declaration

    include_directive = INCLUDE_ID INCLUDE_DIRECTIVE SEMICOLON

    function_declaration = type_specifier IDENTIFIER LEFT_PAREN parameter_list? RIGHT_PAREN compound_statement

    type_specifier = (int / void / char / bool / float / long)

    parameter_list = parameter (COMMA parameter)*

    parameter = type_specifier IDENTIFIER

    compound_statement = LEFT_BRACE declaration* statement* RIGHT_BRACE

    statement = expression_statement / compound_statement / selection_statement / iteration_statement / jump_statement

    expression_statement = expression? SEMICOLON

    selection_statement = if_statement / if_else_statement

    if_statement = if LEFT_PAREN expression RIGHT_PAREN statement

    if_else_statement = if LEFT_PAREN expression RIGHT_PAREN statement else statement

    iteration_statement = while LEFT_PAREN expression RIGHT_PAREN statement

    jump_statement = return expression? SEMICOLON

    expression = assignment_expression

    assignment_expression = equality_expression (ASSIGN equality_expression)*

    equality_expression = relational_expression (EQUAL relational_expression / NOT_EQUAL relational_expression)*

    relational_expression = additive_expression (LESS_THAN additive_expression / GREATER_THAN additive_expression / LESS_THAN_EQUAL additive_expression / GREATER_THAN_EQUAL additive_expression)*

    additive_expression = multiplicative_expression (PLUS multiplicative_expression / MINUS multiplicative_expression)*

    multiplicative_expression = unary_expression (MULTIPLY unary_expression / DIVIDE unary_expression / MODULUS unary_expression)*

    unary_expression = PLUS primary_expression / MINUS primary_expression / NOT primary_expression / primary_expression

    primary_expression = INTEGER / FLOAT / CHAR / STRING / IDENTIFIER / function_call / LEFT_PAREN expression RIGHT_PAREN

    function_call = IDENTIFIER LEFT_PAREN argument_list? RIGHT_PAREN

    argument_list = expression (COMMA expression)*
    """
)


# Define a function that takes a list of tokens generated by lexical_analyzer() and returns an abstract syntax tree (AST) based on the CFG
def parse(tokens):
    def expression(s):
        return s[0]

    def integer(s):
        return int(s[0])

    def float(s):
        return float(s[0])

    def char(s):
        return s[0][1]

    def string(s):
        return s[0][1:-1]

    def identifier(s):
        return s[0]

    def function_call(s):
        return {'type': 'function_call', 'name': s[0], 'args': s[1] or []}

    def argument_list(s):
        return s[0::2]

    def type_specifier(s):
        return s[0]

    def parameter(s):
        return {'type': 'parameter', 'type_specifier': s[0], 'name': s[1]}

    def parameter_list(s):
        return s[0::2]

    def assignment_expression(s):
        if len(s) == 1:
            return s[0]
        else:
            return {'type': 'assignment', 'left': s[0], 'right': s[2]}

    def equality_expression(s):
        if len(s) == 1:
            return s[0]

