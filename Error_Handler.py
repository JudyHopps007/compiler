import lexical_Analyzer

tokens = lexical_Analyzer.lexical_analyzer('program.c')
import pyparsing as pp

# Define the grammar using pyparsing constructs
expr = pp.Forward()
identifier = pp.Regex(r'[a-zA-Z_][a-zA-Z0-9_]*')
integer = pp.Regex(r'\d+')
floating_point = pp.Regex(r'\d+\.\d+')
char_literal = pp.QuotedString("'", escChar='\\')
string_literal = pp.QuotedString('"', escChar='\\')
type_name = pp.oneOf('int void char bool float long')
operator = pp.oneOf('+ - * / % = == != < > <= >= && || !')
left_paren = pp.Literal('(').suppress()
right_paren = pp.Literal(')').suppress()
left_brace = pp.Literal('{').suppress()
right_brace = pp.Literal('}').suppress()
semicolon = pp.Literal(';').suppress()
comma = pp.Literal(',').suppress()

arg = pp.Group(expr + pp.ZeroOrMore(comma + expr))
func_call = pp.Group(identifier + left_paren + pp.Optional(arg) + right_paren)

func_decl = pp.Group(type_name + identifier + left_paren + pp.Optional(arg) + right_paren + left_brace + pp.ZeroOrMore(expr) + right_brace)
var_decl = pp.Group(type_name + identifier + semicolon)

if_stmt = pp.Group(pp.Keyword('if') + left_paren + expr + right_paren + left_brace + pp.ZeroOrMore(expr) + right_brace + pp.Optional(pp.Keyword('else') + left_brace + pp.ZeroOrMore(expr) + right_brace))
while_loop = pp.Group(pp.Keyword('while') + left_paren + expr + right_paren + left_brace + pp.ZeroOrMore(expr) + right_brace)

expression_term = floating_point | integer | char_literal | string_literal | func_call | identifier
unary_expression = pp.Forward()
unary_expression <<= operator + expression_term | expression_term
multiplicative_expression = unary_expression + pp.ZeroOrMore(pp.oneOf('* / %').suppress() + unary_expression)
additive_expression = multiplicative_expression + pp.ZeroOrMore(pp.oneOf('+ -').suppress() + multiplicative_expression)
relational_expression = additive_expression + pp.ZeroOrMore(pp.oneOf('< > <= >=').suppress() + additive_expression)
equality_expression = relational_expression + pp.ZeroOrMore(pp.oneOf('== !=').suppress() + relational_expression)
logical_and_expression = equality_expression + pp.ZeroOrMore(pp.Keyword('&&').suppress() + equality_expression)
logical_or_expression = logical_and_expression + pp.ZeroOrMore(pp.Keyword('||').suppress() + logical_and_expression)
expr <<= logical_or_expression

program = pp.ZeroOrMore(func_decl | var_decl | if_stmt | while_loop)

# Define a function that takes a list of tokens generated by the lexical analyzer and returns a parse tree
def syntax_analyzer(tokens):
    try:
        parse_tree = program.parse(tokens)
        return parse_tree.asList()
    except pp.ParseException as e:
        print("Syntax Error: ", e)
        return None

syntax_analyzer(tokens)